# Generated from cnf_formula.g4 by ANTLR 4.9
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3$")
        buf.write("\u00bb\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \3\2\3\2\3\2\3\2\3\3\3\3\3\3\5\3H\n\3")
        buf.write("\3\4\3\4\3\5\3\5\5\5N\n\5\3\6\3\6\3\7\3\7\3\7\3\7\3\b")
        buf.write("\3\b\3\t\3\t\3\t\3\t\3\t\3\t\5\t^\n\t\3\n\3\n\5\nb\n\n")
        buf.write("\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f\5\fl\n\f\3\r\3\r\3")
        buf.write("\r\3\r\3\r\3\r\5\rt\n\r\3\16\3\16\3\16\7\16y\n\16\f\16")
        buf.write("\16\16|\13\16\3\17\3\17\5\17\u0080\n\17\3\20\3\20\3\20")
        buf.write("\5\20\u0085\n\20\3\21\3\21\3\21\3\21\3\21\5\21\u008c\n")
        buf.write("\21\3\22\3\22\3\22\3\22\3\22\3\22\7\22\u0094\n\22\f\22")
        buf.write("\16\22\u0097\13\22\3\23\3\23\3\23\3\23\5\23\u009d\n\23")
        buf.write("\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27\3\30\3\30\3\31")
        buf.write("\3\31\3\32\3\32\3\33\3\33\5\33\u00af\n\33\3\34\3\34\3")
        buf.write("\35\3\35\3\36\3\36\3\37\3\37\3 \3 \3 \2\3\"!\2\4\6\b\n")
        buf.write("\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<")
        buf.write(">\2\5\3\2\t\n\3\2\37 \5\2\13\13\16\16\21\21\2\u00ab\2")
        buf.write("@\3\2\2\2\4G\3\2\2\2\6I\3\2\2\2\bM\3\2\2\2\nO\3\2\2\2")
        buf.write("\fQ\3\2\2\2\16U\3\2\2\2\20]\3\2\2\2\22a\3\2\2\2\24c\3")
        buf.write("\2\2\2\26k\3\2\2\2\30s\3\2\2\2\32u\3\2\2\2\34\177\3\2")
        buf.write("\2\2\36\u0084\3\2\2\2 \u008b\3\2\2\2\"\u008d\3\2\2\2$")
        buf.write("\u009c\3\2\2\2&\u009e\3\2\2\2(\u00a0\3\2\2\2*\u00a2\3")
        buf.write("\2\2\2,\u00a4\3\2\2\2.\u00a6\3\2\2\2\60\u00a8\3\2\2\2")
        buf.write("\62\u00aa\3\2\2\2\64\u00ae\3\2\2\2\66\u00b0\3\2\2\28\u00b2")
        buf.write("\3\2\2\2:\u00b4\3\2\2\2<\u00b6\3\2\2\2>\u00b8\3\2\2\2")
        buf.write("@A\5\34\17\2AB\7\b\2\2BC\5\34\17\2C\3\3\2\2\2DH\5\6\4")
        buf.write("\2EH\5\b\5\2FH\5\16\b\2GD\3\2\2\2GE\3\2\2\2GF\3\2\2\2")
        buf.write("H\5\3\2\2\2IJ\5\20\t\2J\7\3\2\2\2KN\5\n\6\2LN\5\f\7\2")
        buf.write("MK\3\2\2\2ML\3\2\2\2N\t\3\2\2\2OP\5\22\n\2P\13\3\2\2\2")
        buf.write("QR\5\34\17\2RS\5&\24\2ST\5\34\17\2T\r\3\2\2\2UV\5\30\r")
        buf.write("\2V\17\3\2\2\2W^\5(\25\2XY\5*\26\2YZ\7\3\2\2Z[\5\32\16")
        buf.write("\2[\\\7\4\2\2\\^\3\2\2\2]W\3\2\2\2]X\3\2\2\2^\21\3\2\2")
        buf.write("\2_b\5\64\33\2`b\5\24\13\2a_\3\2\2\2a`\3\2\2\2b\23\3\2")
        buf.write("\2\2cd\5\26\f\2d\25\3\2\2\2el\5\60\31\2fg\5\62\32\2gh")
        buf.write("\7\3\2\2hi\5\32\16\2ij\7\4\2\2jl\3\2\2\2ke\3\2\2\2kf\3")
        buf.write("\2\2\2l\27\3\2\2\2mt\5,\27\2no\5.\30\2op\7\3\2\2pq\5\32")
        buf.write("\16\2qr\7\4\2\2rt\3\2\2\2sm\3\2\2\2sn\3\2\2\2t\31\3\2")
        buf.write("\2\2uz\5\34\17\2vw\7\5\2\2wy\5\34\17\2xv\3\2\2\2y|\3\2")
        buf.write("\2\2zx\3\2\2\2z{\3\2\2\2{\33\3\2\2\2|z\3\2\2\2}\u0080")
        buf.write("\5\36\20\2~\u0080\5\66\34\2\177}\3\2\2\2\177~\3\2\2\2")
        buf.write("\u0080\35\3\2\2\2\u0081\u0085\5\20\t\2\u0082\u0085\5\22")
        buf.write("\n\2\u0083\u0085\5\30\r\2\u0084\u0081\3\2\2\2\u0084\u0082")
        buf.write("\3\2\2\2\u0084\u0083\3\2\2\2\u0085\37\3\2\2\2\u0086\u008c")
        buf.write("\5\"\22\2\u0087\u0088\7\3\2\2\u0088\u0089\5\"\22\2\u0089")
        buf.write("\u008a\7\4\2\2\u008a\u008c\3\2\2\2\u008b\u0086\3\2\2\2")
        buf.write("\u008b\u0087\3\2\2\2\u008c!\3\2\2\2\u008d\u008e\b\22\1")
        buf.write("\2\u008e\u008f\5$\23\2\u008f\u0095\3\2\2\2\u0090\u0091")
        buf.write("\f\3\2\2\u0091\u0092\7\6\2\2\u0092\u0094\5$\23\2\u0093")
        buf.write("\u0090\3\2\2\2\u0094\u0097\3\2\2\2\u0095\u0093\3\2\2\2")
        buf.write("\u0095\u0096\3\2\2\2\u0096#\3\2\2\2\u0097\u0095\3\2\2")
        buf.write("\2\u0098\u009d\5\4\3\2\u0099\u009a\7\7\2\2\u009a\u009d")
        buf.write("\5\4\3\2\u009b\u009d\5\2\2\2\u009c\u0098\3\2\2\2\u009c")
        buf.write("\u0099\3\2\2\2\u009c\u009b\3\2\2\2\u009d%\3\2\2\2\u009e")
        buf.write("\u009f\t\2\2\2\u009f\'\3\2\2\2\u00a0\u00a1\5*\26\2\u00a1")
        buf.write(")\3\2\2\2\u00a2\u00a3\58\35\2\u00a3+\3\2\2\2\u00a4\u00a5")
        buf.write("\5.\30\2\u00a5-\3\2\2\2\u00a6\u00a7\5<\37\2\u00a7/\3\2")
        buf.write("\2\2\u00a8\u00a9\5\62\32\2\u00a9\61\3\2\2\2\u00aa\u00ab")
        buf.write("\5:\36\2\u00ab\63\3\2\2\2\u00ac\u00af\5> \2\u00ad\u00af")
        buf.write("\7!\2\2\u00ae\u00ac\3\2\2\2\u00ae\u00ad\3\2\2\2\u00af")
        buf.write("\65\3\2\2\2\u00b0\u00b1\7\36\2\2\u00b1\67\3\2\2\2\u00b2")
        buf.write("\u00b3\t\3\2\2\u00b39\3\2\2\2\u00b4\u00b5\7\34\2\2\u00b5")
        buf.write(";\3\2\2\2\u00b6\u00b7\7\35\2\2\u00b7=\3\2\2\2\u00b8\u00b9")
        buf.write("\t\4\2\2\u00b9?\3\2\2\2\17GM]aksz\177\u0084\u008b\u0095")
        buf.write("\u009c\u00ae")
        return buf.getvalue()


class cnf_formulaParser ( Parser ):

    grammarFileName = "cnf_formula.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "')'", "','", "'|'", "'~'", "'!='", 
                     "'='", "':='" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "Or", "Not", "Infix_inequality", "Infix_equality", 
                      "Assignment", "Real", "Signed_real", "Unsigned_real", 
                      "Rational", "Signed_rational", "Unsigned_rational", 
                      "Integer", "Signed_integer", "Unsigned_integer", "Decimal", 
                      "Positive_decimal", "Decimal_exponent", "Decimal_fraction", 
                      "Dot_decimal", "Exp_integer", "Signed_exp_integer", 
                      "Unsigned_exp_integer", "Dollar_word", "Dollar_dollar_word", 
                      "Upper_word", "Lower_word", "Single_quoted", "Distinct_object", 
                      "WS", "Line_comment", "Block_comment" ]

    RULE_fof_infix_unary = 0
    RULE_fof_atomic_formula = 1
    RULE_fof_plain_atomic_formula = 2
    RULE_fof_defined_atomic_formula = 3
    RULE_fof_defined_plain_formula = 4
    RULE_fof_defined_infix_formula = 5
    RULE_fof_system_atomic_formula = 6
    RULE_fof_plain_term = 7
    RULE_fof_defined_term = 8
    RULE_fof_defined_atomic_term = 9
    RULE_fof_defined_plain_term = 10
    RULE_fof_system_term = 11
    RULE_fof_arguments = 12
    RULE_fof_term = 13
    RULE_fof_function_term = 14
    RULE_cnf_formula = 15
    RULE_cnf_disjunction = 16
    RULE_cnf_literal = 17
    RULE_defined_infix_pred = 18
    RULE_constant = 19
    RULE_functor = 20
    RULE_system_constant = 21
    RULE_system_functor = 22
    RULE_defined_constant = 23
    RULE_defined_functor = 24
    RULE_defined_term = 25
    RULE_variable = 26
    RULE_atomic_word = 27
    RULE_atomic_defined_word = 28
    RULE_atomic_system_word = 29
    RULE_number = 30

    ruleNames =  [ "fof_infix_unary", "fof_atomic_formula", "fof_plain_atomic_formula", 
                   "fof_defined_atomic_formula", "fof_defined_plain_formula", 
                   "fof_defined_infix_formula", "fof_system_atomic_formula", 
                   "fof_plain_term", "fof_defined_term", "fof_defined_atomic_term", 
                   "fof_defined_plain_term", "fof_system_term", "fof_arguments", 
                   "fof_term", "fof_function_term", "cnf_formula", "cnf_disjunction", 
                   "cnf_literal", "defined_infix_pred", "constant", "functor", 
                   "system_constant", "system_functor", "defined_constant", 
                   "defined_functor", "defined_term", "variable", "atomic_word", 
                   "atomic_defined_word", "atomic_system_word", "number" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    Or=4
    Not=5
    Infix_inequality=6
    Infix_equality=7
    Assignment=8
    Real=9
    Signed_real=10
    Unsigned_real=11
    Rational=12
    Signed_rational=13
    Unsigned_rational=14
    Integer=15
    Signed_integer=16
    Unsigned_integer=17
    Decimal=18
    Positive_decimal=19
    Decimal_exponent=20
    Decimal_fraction=21
    Dot_decimal=22
    Exp_integer=23
    Signed_exp_integer=24
    Unsigned_exp_integer=25
    Dollar_word=26
    Dollar_dollar_word=27
    Upper_word=28
    Lower_word=29
    Single_quoted=30
    Distinct_object=31
    WS=32
    Line_comment=33
    Block_comment=34

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Fof_infix_unaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(cnf_formulaParser.Fof_termContext)
            else:
                return self.getTypedRuleContext(cnf_formulaParser.Fof_termContext,i)


        def Infix_inequality(self):
            return self.getToken(cnf_formulaParser.Infix_inequality, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_infix_unary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_infix_unary" ):
                listener.enterFof_infix_unary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_infix_unary" ):
                listener.exitFof_infix_unary(self)




    def fof_infix_unary(self):

        localctx = cnf_formulaParser.Fof_infix_unaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_fof_infix_unary)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.fof_term()
            self.state = 63
            self.match(cnf_formulaParser.Infix_inequality)
            self.state = 64
            self.fof_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_atomic_formulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_atomic_formula(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_plain_atomic_formulaContext,0)


        def fof_defined_atomic_formula(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_defined_atomic_formulaContext,0)


        def fof_system_atomic_formula(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_system_atomic_formulaContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_atomic_formula" ):
                listener.enterFof_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_atomic_formula" ):
                listener.exitFof_atomic_formula(self)




    def fof_atomic_formula(self):

        localctx = cnf_formulaParser.Fof_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_fof_atomic_formula)
        try:
            self.state = 69
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 66
                self.fof_plain_atomic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 67
                self.fof_defined_atomic_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 68
                self.fof_system_atomic_formula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_plain_atomic_formulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_plain_termContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_plain_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_plain_atomic_formula" ):
                listener.enterFof_plain_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_plain_atomic_formula" ):
                listener.exitFof_plain_atomic_formula(self)




    def fof_plain_atomic_formula(self):

        localctx = cnf_formulaParser.Fof_plain_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_fof_plain_atomic_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 71
            self.fof_plain_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_atomic_formulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_defined_plain_formula(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_defined_plain_formulaContext,0)


        def fof_defined_infix_formula(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_defined_infix_formulaContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_defined_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_atomic_formula" ):
                listener.enterFof_defined_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_atomic_formula" ):
                listener.exitFof_defined_atomic_formula(self)




    def fof_defined_atomic_formula(self):

        localctx = cnf_formulaParser.Fof_defined_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_fof_defined_atomic_formula)
        try:
            self.state = 75
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 73
                self.fof_defined_plain_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 74
                self.fof_defined_infix_formula()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_plain_formulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_defined_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_defined_termContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_defined_plain_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_plain_formula" ):
                listener.enterFof_defined_plain_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_plain_formula" ):
                listener.exitFof_defined_plain_formula(self)




    def fof_defined_plain_formula(self):

        localctx = cnf_formulaParser.Fof_defined_plain_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_fof_defined_plain_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.fof_defined_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_infix_formulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(cnf_formulaParser.Fof_termContext)
            else:
                return self.getTypedRuleContext(cnf_formulaParser.Fof_termContext,i)


        def defined_infix_pred(self):
            return self.getTypedRuleContext(cnf_formulaParser.Defined_infix_predContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_defined_infix_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_infix_formula" ):
                listener.enterFof_defined_infix_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_infix_formula" ):
                listener.exitFof_defined_infix_formula(self)




    def fof_defined_infix_formula(self):

        localctx = cnf_formulaParser.Fof_defined_infix_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_fof_defined_infix_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.fof_term()
            self.state = 80
            self.defined_infix_pred()
            self.state = 81
            self.fof_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_system_atomic_formulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_system_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_system_termContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_system_atomic_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_system_atomic_formula" ):
                listener.enterFof_system_atomic_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_system_atomic_formula" ):
                listener.exitFof_system_atomic_formula(self)




    def fof_system_atomic_formula(self):

        localctx = cnf_formulaParser.Fof_system_atomic_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_fof_system_atomic_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.fof_system_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_plain_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self):
            return self.getTypedRuleContext(cnf_formulaParser.ConstantContext,0)


        def functor(self):
            return self.getTypedRuleContext(cnf_formulaParser.FunctorContext,0)


        def fof_arguments(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_argumentsContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_plain_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_plain_term" ):
                listener.enterFof_plain_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_plain_term" ):
                listener.exitFof_plain_term(self)




    def fof_plain_term(self):

        localctx = cnf_formulaParser.Fof_plain_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_fof_plain_term)
        try:
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 85
                self.constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 86
                self.functor()
                self.state = 87
                self.match(cnf_formulaParser.T__0)
                self.state = 88
                self.fof_arguments()
                self.state = 89
                self.match(cnf_formulaParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defined_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Defined_termContext,0)


        def fof_defined_atomic_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_defined_atomic_termContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_defined_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_term" ):
                listener.enterFof_defined_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_term" ):
                listener.exitFof_defined_term(self)




    def fof_defined_term(self):

        localctx = cnf_formulaParser.Fof_defined_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_fof_defined_term)
        try:
            self.state = 95
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [cnf_formulaParser.Real, cnf_formulaParser.Rational, cnf_formulaParser.Integer, cnf_formulaParser.Distinct_object]:
                self.enterOuterAlt(localctx, 1)
                self.state = 93
                self.defined_term()
                pass
            elif token in [cnf_formulaParser.Dollar_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 94
                self.fof_defined_atomic_term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_atomic_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_defined_plain_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_defined_plain_termContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_defined_atomic_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_atomic_term" ):
                listener.enterFof_defined_atomic_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_atomic_term" ):
                listener.exitFof_defined_atomic_term(self)




    def fof_defined_atomic_term(self):

        localctx = cnf_formulaParser.Fof_defined_atomic_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_fof_defined_atomic_term)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.fof_defined_plain_term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_defined_plain_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defined_constant(self):
            return self.getTypedRuleContext(cnf_formulaParser.Defined_constantContext,0)


        def defined_functor(self):
            return self.getTypedRuleContext(cnf_formulaParser.Defined_functorContext,0)


        def fof_arguments(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_argumentsContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_defined_plain_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_defined_plain_term" ):
                listener.enterFof_defined_plain_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_defined_plain_term" ):
                listener.exitFof_defined_plain_term(self)




    def fof_defined_plain_term(self):

        localctx = cnf_formulaParser.Fof_defined_plain_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_fof_defined_plain_term)
        try:
            self.state = 105
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.defined_constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 100
                self.defined_functor()
                self.state = 101
                self.match(cnf_formulaParser.T__0)
                self.state = 102
                self.fof_arguments()
                self.state = 103
                self.match(cnf_formulaParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_system_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def system_constant(self):
            return self.getTypedRuleContext(cnf_formulaParser.System_constantContext,0)


        def system_functor(self):
            return self.getTypedRuleContext(cnf_formulaParser.System_functorContext,0)


        def fof_arguments(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_argumentsContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_system_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_system_term" ):
                listener.enterFof_system_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_system_term" ):
                listener.exitFof_system_term(self)




    def fof_system_term(self):

        localctx = cnf_formulaParser.Fof_system_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_fof_system_term)
        try:
            self.state = 113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 107
                self.system_constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 108
                self.system_functor()
                self.state = 109
                self.match(cnf_formulaParser.T__0)
                self.state = 110
                self.fof_arguments()
                self.state = 111
                self.match(cnf_formulaParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_argumentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(cnf_formulaParser.Fof_termContext)
            else:
                return self.getTypedRuleContext(cnf_formulaParser.Fof_termContext,i)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_arguments" ):
                listener.enterFof_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_arguments" ):
                listener.exitFof_arguments(self)




    def fof_arguments(self):

        localctx = cnf_formulaParser.Fof_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_fof_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self.fof_term()
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==cnf_formulaParser.T__2:
                self.state = 116
                self.match(cnf_formulaParser.T__2)
                self.state = 117
                self.fof_term()
                self.state = 122
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_function_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_function_termContext,0)


        def variable(self):
            return self.getTypedRuleContext(cnf_formulaParser.VariableContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_term" ):
                listener.enterFof_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_term" ):
                listener.exitFof_term(self)




    def fof_term(self):

        localctx = cnf_formulaParser.Fof_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_fof_term)
        try:
            self.state = 125
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [cnf_formulaParser.Real, cnf_formulaParser.Rational, cnf_formulaParser.Integer, cnf_formulaParser.Dollar_word, cnf_formulaParser.Dollar_dollar_word, cnf_formulaParser.Lower_word, cnf_formulaParser.Single_quoted, cnf_formulaParser.Distinct_object]:
                self.enterOuterAlt(localctx, 1)
                self.state = 123
                self.fof_function_term()
                pass
            elif token in [cnf_formulaParser.Upper_word]:
                self.enterOuterAlt(localctx, 2)
                self.state = 124
                self.variable()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fof_function_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_plain_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_plain_termContext,0)


        def fof_defined_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_defined_termContext,0)


        def fof_system_term(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_system_termContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_fof_function_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFof_function_term" ):
                listener.enterFof_function_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFof_function_term" ):
                listener.exitFof_function_term(self)




    def fof_function_term(self):

        localctx = cnf_formulaParser.Fof_function_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_fof_function_term)
        try:
            self.state = 130
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [cnf_formulaParser.Lower_word, cnf_formulaParser.Single_quoted]:
                self.enterOuterAlt(localctx, 1)
                self.state = 127
                self.fof_plain_term()
                pass
            elif token in [cnf_formulaParser.Real, cnf_formulaParser.Rational, cnf_formulaParser.Integer, cnf_formulaParser.Dollar_word, cnf_formulaParser.Distinct_object]:
                self.enterOuterAlt(localctx, 2)
                self.state = 128
                self.fof_defined_term()
                pass
            elif token in [cnf_formulaParser.Dollar_dollar_word]:
                self.enterOuterAlt(localctx, 3)
                self.state = 129
                self.fof_system_term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cnf_formulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cnf_disjunction(self):
            return self.getTypedRuleContext(cnf_formulaParser.Cnf_disjunctionContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_cnf_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCnf_formula" ):
                listener.enterCnf_formula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCnf_formula" ):
                listener.exitCnf_formula(self)




    def cnf_formula(self):

        localctx = cnf_formulaParser.Cnf_formulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_cnf_formula)
        try:
            self.state = 137
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [cnf_formulaParser.Not, cnf_formulaParser.Real, cnf_formulaParser.Rational, cnf_formulaParser.Integer, cnf_formulaParser.Dollar_word, cnf_formulaParser.Dollar_dollar_word, cnf_formulaParser.Upper_word, cnf_formulaParser.Lower_word, cnf_formulaParser.Single_quoted, cnf_formulaParser.Distinct_object]:
                self.enterOuterAlt(localctx, 1)
                self.state = 132
                self.cnf_disjunction(0)
                pass
            elif token in [cnf_formulaParser.T__0]:
                self.enterOuterAlt(localctx, 2)
                self.state = 133
                self.match(cnf_formulaParser.T__0)
                self.state = 134
                self.cnf_disjunction(0)
                self.state = 135
                self.match(cnf_formulaParser.T__1)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cnf_disjunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cnf_literal(self):
            return self.getTypedRuleContext(cnf_formulaParser.Cnf_literalContext,0)


        def cnf_disjunction(self):
            return self.getTypedRuleContext(cnf_formulaParser.Cnf_disjunctionContext,0)


        def Or(self):
            return self.getToken(cnf_formulaParser.Or, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_cnf_disjunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCnf_disjunction" ):
                listener.enterCnf_disjunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCnf_disjunction" ):
                listener.exitCnf_disjunction(self)



    def cnf_disjunction(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = cnf_formulaParser.Cnf_disjunctionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 32
        self.enterRecursionRule(localctx, 32, self.RULE_cnf_disjunction, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.cnf_literal()
            self._ctx.stop = self._input.LT(-1)
            self.state = 147
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = cnf_formulaParser.Cnf_disjunctionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_cnf_disjunction)
                    self.state = 142
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 143
                    self.match(cnf_formulaParser.Or)
                    self.state = 144
                    self.cnf_literal() 
                self.state = 149
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Cnf_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fof_atomic_formula(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_atomic_formulaContext,0)


        def Not(self):
            return self.getToken(cnf_formulaParser.Not, 0)

        def fof_infix_unary(self):
            return self.getTypedRuleContext(cnf_formulaParser.Fof_infix_unaryContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_cnf_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCnf_literal" ):
                listener.enterCnf_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCnf_literal" ):
                listener.exitCnf_literal(self)




    def cnf_literal(self):

        localctx = cnf_formulaParser.Cnf_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_cnf_literal)
        try:
            self.state = 154
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 150
                self.fof_atomic_formula()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 151
                self.match(cnf_formulaParser.Not)
                self.state = 152
                self.fof_atomic_formula()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 153
                self.fof_infix_unary()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_infix_predContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Infix_equality(self):
            return self.getToken(cnf_formulaParser.Infix_equality, 0)

        def Assignment(self):
            return self.getToken(cnf_formulaParser.Assignment, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_defined_infix_pred

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_infix_pred" ):
                listener.enterDefined_infix_pred(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_infix_pred" ):
                listener.exitDefined_infix_pred(self)




    def defined_infix_pred(self):

        localctx = cnf_formulaParser.Defined_infix_predContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_defined_infix_pred)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 156
            _la = self._input.LA(1)
            if not(_la==cnf_formulaParser.Infix_equality or _la==cnf_formulaParser.Assignment):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functor(self):
            return self.getTypedRuleContext(cnf_formulaParser.FunctorContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = cnf_formulaParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.functor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_word(self):
            return self.getTypedRuleContext(cnf_formulaParser.Atomic_wordContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_functor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctor" ):
                listener.enterFunctor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctor" ):
                listener.exitFunctor(self)




    def functor(self):

        localctx = cnf_formulaParser.FunctorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_functor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.atomic_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class System_constantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def system_functor(self):
            return self.getTypedRuleContext(cnf_formulaParser.System_functorContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_system_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystem_constant" ):
                listener.enterSystem_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystem_constant" ):
                listener.exitSystem_constant(self)




    def system_constant(self):

        localctx = cnf_formulaParser.System_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_system_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.system_functor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class System_functorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_system_word(self):
            return self.getTypedRuleContext(cnf_formulaParser.Atomic_system_wordContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_system_functor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystem_functor" ):
                listener.enterSystem_functor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystem_functor" ):
                listener.exitSystem_functor(self)




    def system_functor(self):

        localctx = cnf_formulaParser.System_functorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_system_functor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.atomic_system_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_constantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defined_functor(self):
            return self.getTypedRuleContext(cnf_formulaParser.Defined_functorContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_defined_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_constant" ):
                listener.enterDefined_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_constant" ):
                listener.exitDefined_constant(self)




    def defined_constant(self):

        localctx = cnf_formulaParser.Defined_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_defined_constant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.defined_functor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_functorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atomic_defined_word(self):
            return self.getTypedRuleContext(cnf_formulaParser.Atomic_defined_wordContext,0)


        def getRuleIndex(self):
            return cnf_formulaParser.RULE_defined_functor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_functor" ):
                listener.enterDefined_functor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_functor" ):
                listener.exitDefined_functor(self)




    def defined_functor(self):

        localctx = cnf_formulaParser.Defined_functorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_defined_functor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.atomic_defined_word()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Defined_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(cnf_formulaParser.NumberContext,0)


        def Distinct_object(self):
            return self.getToken(cnf_formulaParser.Distinct_object, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_defined_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefined_term" ):
                listener.enterDefined_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefined_term" ):
                listener.exitDefined_term(self)




    def defined_term(self):

        localctx = cnf_formulaParser.Defined_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_defined_term)
        try:
            self.state = 172
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [cnf_formulaParser.Real, cnf_formulaParser.Rational, cnf_formulaParser.Integer]:
                self.enterOuterAlt(localctx, 1)
                self.state = 170
                self.number()
                pass
            elif token in [cnf_formulaParser.Distinct_object]:
                self.enterOuterAlt(localctx, 2)
                self.state = 171
                self.match(cnf_formulaParser.Distinct_object)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Upper_word(self):
            return self.getToken(cnf_formulaParser.Upper_word, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)




    def variable(self):

        localctx = cnf_formulaParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(cnf_formulaParser.Upper_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_wordContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Lower_word(self):
            return self.getToken(cnf_formulaParser.Lower_word, 0)

        def Single_quoted(self):
            return self.getToken(cnf_formulaParser.Single_quoted, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_atomic_word

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_word" ):
                listener.enterAtomic_word(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_word" ):
                listener.exitAtomic_word(self)




    def atomic_word(self):

        localctx = cnf_formulaParser.Atomic_wordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_atomic_word)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            _la = self._input.LA(1)
            if not(_la==cnf_formulaParser.Lower_word or _la==cnf_formulaParser.Single_quoted):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_defined_wordContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dollar_word(self):
            return self.getToken(cnf_formulaParser.Dollar_word, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_atomic_defined_word

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_defined_word" ):
                listener.enterAtomic_defined_word(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_defined_word" ):
                listener.exitAtomic_defined_word(self)




    def atomic_defined_word(self):

        localctx = cnf_formulaParser.Atomic_defined_wordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_atomic_defined_word)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(cnf_formulaParser.Dollar_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Atomic_system_wordContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Dollar_dollar_word(self):
            return self.getToken(cnf_formulaParser.Dollar_dollar_word, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_atomic_system_word

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomic_system_word" ):
                listener.enterAtomic_system_word(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomic_system_word" ):
                listener.exitAtomic_system_word(self)




    def atomic_system_word(self):

        localctx = cnf_formulaParser.Atomic_system_wordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_atomic_system_word)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(cnf_formulaParser.Dollar_dollar_word)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Integer(self):
            return self.getToken(cnf_formulaParser.Integer, 0)

        def Rational(self):
            return self.getToken(cnf_formulaParser.Rational, 0)

        def Real(self):
            return self.getToken(cnf_formulaParser.Real, 0)

        def getRuleIndex(self):
            return cnf_formulaParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = cnf_formulaParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << cnf_formulaParser.Real) | (1 << cnf_formulaParser.Rational) | (1 << cnf_formulaParser.Integer))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[16] = self.cnf_disjunction_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def cnf_disjunction_sempred(self, localctx:Cnf_disjunctionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         




